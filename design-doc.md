# Design Document: Generative Floor Plan (Gemini Integration)

## 1. Overview
The goal is to replace the hardcoded initial floor plan in `FloorPlanApp` with a dynamic one generated by Google's Gemini model based on a user text prompt.

## 2. Data Modeling (Zod Schema)
We need a Zod schema that strictly matches the existing `Room` and `Door` interfaces in `src/types/index.ts`.

```typescript
import { z } from 'zod';

// Matches 'borders' in Room interface
const BorderSchema = z.object({
  top: z.boolean(),
  bottom: z.boolean(),
  left: z.boolean(),
  right: z.boolean(),
});

// Matches 'Room' interface
export const RoomSchema = z.object({
  id: z.string().describe("Unique identifier for the room, e.g., 'room_1'"),
  name: z.string().describe("Display name, e.g., 'Master Bedroom'"),
  dimensions: z.string().describe("Text description of dimensions, e.g., '15' x 12''"),
  details: z.string().describe("Brief description of the room's purpose"),
  x: z.number().describe("X coordinate on the grid"),
  y: z.number().describe("Y coordinate on the grid"),
  w: z.number().describe("Width in grid units"),
  h: z.number().describe("Height in grid units"),
  type: z.enum(['bedroom', 'bathroom', 'living', 'utility', 'outdoor', 'kitchen', 'dining'])
    .describe("Type of room for styling purposes"),
  borders: BorderSchema,
});

// Matches 'Door' interface
export const DoorSchema = z.object({
  id: z.string().describe("Unique identifier, e.g., 'door_1'"),
  x: z.number(),
  y: z.number(),
  orientation: z.enum(['horizontal', 'vertical']),
  swing: z.enum(['left', 'right']),
});

// The top-level schema for the LLM response
export const FloorPlanSchema = z.object({
  rooms: z.array(RoomSchema),
  doors: z.array(DoorSchema),
});
```

## 3. Architecture & Integration

### A. AI Integration (Server Side)
We will use the **Vercel AI SDK** (`ai`) with the **Google Generative AI Provider** (`@ai-sdk/google`) to interact with Gemini. This provides a clean `generateObject` function that enforces the Zod schema.

*   **File**: `src/app/actions/generate-plan.ts` (Server Action)
*   **Functionality**: 
    1.  Receives user prompt string.
    2.  Calls Gemini with a system prompt instructing it to design a floor plan layout.
    3.  Returns the structured JSON conforming to `FloorPlanSchema`.

### B. User Interface (Client Side)
We will modify `src/components/FloorPlanApp.tsx` to handle the "Empty/Start" state.

1.  **State Management**:
    *   Change `initialRooms` and `initialDoors` to start as empty arrays (or `null`).
    *   Add `isGenerating` (boolean) loading state.
    
2.  **New Component**: `src/components/floor-plan/PromptModal.tsx`
    *   A centered modal/overlay that appears when `rooms.length === 0`.
    *   Contains: Textarea for prompt, "Generate" button, and some example prompts (e.g., "A 2-bedroom apartment with an open kitchen").

3.  **Flow**:
    *   App Load -> `rooms` is empty -> Show `PromptModal`.
    *   User types prompt -> Clicks "Generate".
    *   `FloorPlanApp` calls Server Action.
    *   Show Loading Spinner.
    *   On success -> `setRooms` / `setDoors` with result -> Modal disappears -> Canvas renders.

## 4. Implementation Plan

### Step 1: Dependencies
Install necessary packages:
`pnpm add zod ai @ai-sdk/google`

### Step 2: Server Action
Create `src/app/actions/generate-plan.ts`:
*   Import `google` from `@ai-sdk/google`.
*   Import `generateObject`.
*   Define the prompt and schema.
*   *Note: Requires `GOOGLE_GENERATIVE_AI_API_KEY` in `.env.local`.*

### Step 3: UI Components
1.  Create `src/components/floor-plan/PromptModal.tsx`.
2.  Modify `src/components/FloorPlanApp.tsx`:
    *   Remove hardcoded `initialRooms` / `initialDoors` (or move them to a "Load Sample" button).
    *   Integrate `PromptModal`.
    *   Handle the async generation call.

### Step 4: Refinement (Self-Correction)
*   *Coordinate System*: The LLM might struggle with perfect alignment (walls touching). 
*   *Mitigation*: We can ask the LLM to assume a grid system where 1 unit = ~1 foot, and try to align coordinates integers. The existing "magnetic snap" logic in the client handles movement, but the initial render relies on the provided coordinates.
